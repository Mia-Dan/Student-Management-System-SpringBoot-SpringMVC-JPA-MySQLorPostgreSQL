ERROR:

request ---

GET http://localhost:8080/emps?begin=2007-09-01&end=2022-10-01

returns ---

{
    "timestamp": "2024-01-03T10:58:45.246+00:00",
    "status": 500,
    "error": "Internal Server Error",
    "path": "/emps"
}

with logs ---

2024-01-03 18:58:45.231  WARN 9332 --- [nio-8080-exec-2] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 0, SQLState: 42P18
2024-01-03 18:58:45.231 ERROR 9332 --- [nio-8080-exec-2] o.h.engine.jdbc.spi.SqlExceptionHelper   : ERROR: could not determine data type of parameter $7
2024-01-03 18:58:45.242 ERROR 9332 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.dao.InvalidDataAccessResourceUsageException: could not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet] with root cause

org.postgresql.util.PSQLException: ERROR: could not determine data type of parameter $7

analysis ---

问题确实出现在:begin is null那里，其中begin时LocalDate类型（String和Short类型没出问题；e.entrydate between :begin and :end没出问题）


solution ---
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.TypedQuery;

in JPA are used to create type-safe queries // Copilot says that - TOCHECK
// but it works anyway



2024-01-04 13:55:29.555  INFO 20328 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
Hibernate:
    /* select
        generatedAlias0
    from
        Emp as generatedAlias0
    where
        (
            generatedAlias0.gender=1
        )
        and (
            generatedAlias0.entrydate between :param0 and :param1
        ) */ select
            emp0_.id as id1_1_,
            emp0_.create_time as create_t2_1_,
            emp0_.dept_id as dept_id3_1_,
            emp0_.entrydate as entrydat4_1_,
            emp0_.gender as gender5_1_,
            emp0_.image as image6_1_,
            emp0_.job as job7_1_,
            emp0_.name as name8_1_,
            emp0_.password as password9_1_,
            emp0_.update_time as update_10_1_,
            emp0_.username as usernam11_1_
        from
            emp emp0_
        where
            emp0_.gender=1
            and (
                emp0_.entrydate between ? and ?
            ) limit ?

// 可以看到，生成的JPQL中压根没有:begin is null这个条件，
// 而是直接在Java代码里(begin != null && end != null)判断为True，启动了这个分支将条件（emp0_.entrydate between ? and ?）加入predicates，避免了问题

code snippets---

public class CustomEmpRepositoryImpl implements CustomEmpRepository {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<Emp> queryByLots(Pageable pageable, String name, Short gender, LocalDate begin, LocalDate end) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<Emp> cq = cb.createQuery(Emp.class);

        Root<Emp> emp = cq.from(Emp.class);
        List<Predicate> predicates = new ArrayList<>();

        if (name != null) {
            predicates.add(cb.like(emp.get("name"), "%" + name + "%"));
        }
        if (gender != null) {
            predicates.add(cb.equal(emp.get("gender"), gender));
        }
        if (begin != null && end != null) {
            predicates.add(cb.between(emp.get("entrydate"), begin, end));
        }

        cq.where(predicates.toArray(new Predicate[0]));
        TypedQuery<Emp> query = entityManager.createQuery(cq);

        query.setFirstResult((int) pageable.getOffset());
        query.setMaxResults(pageable.getPageSize());

        return query.getResultList();
    }
}